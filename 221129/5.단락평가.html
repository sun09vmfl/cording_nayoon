<script>
  /* 
    단락평가(단락회로평가): 논리 연산자의 특성을 이용하여 구문 작성

      truthy: 참인듯
        빈배열[], 빈객체{}, 

      falsy(falsey): 거짓인듯
        false, 0, -0(-1,-2), '', null, underined, NaN . . .

        boolean && 실행문장, boolean || 실행문장
        || OR 연산자
        true || 조건 -> 왼쪽이 참이면 오른쪽은 실행 x
        false || 조건 -> 왼쪽이 거짓이면 오른쪽의 내용이 반환

        && AND 연산자
        false && 조건  -> 왼쪽이 거짓이면 오른쪽 실행 x
  */

  console.log(false && true); // false
  // A의 값이 거짓인 경우 B의 값을 탐색할 필요도 없이 거짓이 되므로 falsy
  false && console.log(`A가 거짓이면 이 내용은 반환되지 않음`);

  console.log(true && false && true); //false
  // A와 B의 값이 false이기 때문에 C까지 가지 않고 멈춤 falsy
  true && console.log(`A가 참이면 이 내용은 반환됨`);

  console.log(true || false); // true
  //OR 연산자는 둘 중 하나만 참이어도 true
  // A값이 true인 경우 B의 값을 탐색할 필요도 없이 참이므로 truthy
  true || console.log(`A가 참이면 이 내용은 반환되지 않음.`);
  false || console.log(`A가 거짓이면 이 내용은 반환됨.`);

  console.log(false || true || true); // true
  // A||B 먼저 연산 후 결과값과 ||C 로 연산됨
  // A와 B를 먼저 읽어 true가 나오면 C의 값을 탐색할 필요도 없이 멈춤 truthy

  false || console.log(`A가 거짓이면 이 내용은 반환됨.`);

  console.log("" || "a");
  // 빈 문자열의 경우 false의 값이므로 뒤의 값까지 읽어야 함. 그래서 a가 출력.
  // a <- true, false로 연산 후 원래 값으로 반환.

  console.log("" || "a" || 222); // a
  // ''와 'a' 연산 후 a가 참이기 때문에 222까지 넘어가지 않고 truthy를 만나는 순간 멈춤

  console.log([] && "" && 222); // ''
  // [] truthy, '' falsy, 이기 때문에 222로 넘어가지 못하고 멈춤.

  console.log([] && {} && 222); // 222 출력
  // [], {} truthy
  // truthy && 222 -> truthy
</script>
